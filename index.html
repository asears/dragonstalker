<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dragon Stalker - Night Stalker Clone</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }
        
        h1 {
            text-align: center;
            color: #ff0;
            text-shadow: 0 0 10px #ff0;
        }
        
        #gameContainer {
            position: relative;
            width: 640px;
            height: 480px;
            background: #000;
            border: 4px solid #0f0;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
            margin: 20px auto;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        #controls {
            margin-top: 20px;
            text-align: center;
            max-width: 640px;
        }
        
        #controls p {
            margin: 10px 0;
            color: #0f0;
        }
        
        button {
            background: #0a0;
            color: #000;
            border: 2px solid #0f0;
            padding: 10px 20px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            cursor: pointer;
            margin: 5px;
            text-transform: uppercase;
        }
        
        button:hover {
            background: #0f0;
            box-shadow: 0 0 10px #0f0;
        }
        
        #status {
            text-align: center;
            color: #ff0;
            font-size: 14px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>üêâ DRAGON STALKER üêâ</h1>
    <div id="status">Loading game...</div>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" width="320" height="240"></canvas>
    </div>
    
    <div id="controls">
        <p><strong>CONTROLS:</strong></p>
        <p>Arrow Keys: Move | Z: Fire Yellow Disc | R: Restart</p>
        <p>Enemies: üï∑Ô∏èSpider(100)+Webs ü¶ÇScorpion(150) üêçSnake(175) ü¶áBat(200) üêâDragon(250) ü§ñRobot(300)+Discs</p>
        <p>‚ö†Ô∏è Watch for the robot patrolling and shooting red discs!</p>
        <button onclick="startGame()">START GAME</button>
        <button onclick="resetGame()">RESET</button>
    </div>

    <script>
        // Night Stalker WASM Container Emulation
        // Enhanced JavaScript-based Intellivision BASIC interpreter
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusDiv = document.getElementById('status');
        
        // Audio context for sound effects
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx = null;
        
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new AudioContext();
            }
        }
        
        // Early 80s arcade sound effects using Web Audio API
        function playShootSound() {
            if (!audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.1);
            
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.1);
        }
        
        function playHitSound() {
            if (!audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.2);
            
            gainNode.gain.setValueAtTime(0.4, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.2);
        }
        
        function playKillSound() {
            if (!audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            oscillator.type = 'triangle';
            oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.3);
            
            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.3);
        }
        
        function playLevelUpSound() {
            if (!audioCtx) return;
            const notes = [262, 330, 392, 523]; // C, E, G, C (major chord)
            notes.forEach((freq, i) => {
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.value = freq;
                
                const startTime = audioCtx.currentTime + i * 0.1;
                gainNode.gain.setValueAtTime(0.2, startTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.15);
                
                oscillator.start(startTime);
                oscillator.stop(startTime + 0.15);
            });
        }
        
        function playGameOverSound() {
            if (!audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.8);
            
            gainNode.gain.setValueAtTime(0.4, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.8);
            
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.8);
        }
        
        function playRobotShootSound() {
            if (!audioCtx) return;
            // Robotic "zing" sound
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(1200, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.15);
            
            gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
            
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.15);
        }
        
        // Animation frame counter
        let frameCount = 0;
        
        // Game state
        let gameState = {
            score: 1000,
            lives: 5,
            bullets: 999,
            level: 1,
            startDelay: 120,
            player: { 
                x: 160, y: 120, size: 8, color: '#fff', 
                direction: 'down', animFrame: 0, moving: false 
            },
            enemies: [
                { x: 70, y: 60, size: 8, color: '#f0f', type: 'spider', alive: true, animFrame: 0, wanderTarget: null, lastShot: 0 },
                { x: 280, y: 100, size: 8, color: '#00f', type: 'scorpion', alive: true, animFrame: 0, wanderTarget: null },
                { x: 280, y: 200, size: 8, color: '#f00', type: 'snake', alive: true, animFrame: 0, wanderTarget: null },
                { x: 70, y: 200, size: 8, color: '#8b4513', type: 'bat', alive: true, animFrame: 0, direction: 1 },
                { x: 280, y: 60, size: 8, color: '#ff1493', type: 'dragon', alive: true, animFrame: 0, wanderTarget: null }
            ],
            robot: { x: 160, y: 120, size: 10, color: '#888', type: 'robot', alive: false, animFrame: 0, wanderTarget: null },
            activeBullets: [],
            bunker: { x: 140, y: 100, width: 40, height: 40 },
            keys: {},
            gameOver: false,
            running: false
        };
        
        // Maze walls from the image - enhanced for better layout
        const walls = [
            // Outer walls
            {x: 0, y: 0, width: 320, height: 8},
            {x: 0, y: 232, width: 320, height: 8},
            {x: 0, y: 0, width: 8, height: 240},
            {x: 312, y: 0, width: 8, height: 240},
            
            // Internal maze walls (more detailed from image)
            {x: 25, y: 25, width: 60, height: 45},
            {x: 220, y: 25, width: 70, height: 60},
            {x: 25, y: 165, width: 50, height: 55},
            {x: 235, y: 160, width: 55, height: 60},
            {x: 115, y: 45, width: 10, height: 100},
            {x: 185, y: 45, width: 10, height: 100},
            {x: 50, y: 100, width: 45, height: 12},
            {x: 210, y: 105, width: 45, height: 12},
            {x: 100, y: 175, width: 110, height: 12},
            // Left wall
            {x: 0, y: 8, width: 8, height: 232}
        ];
        
        // Input handling
        document.addEventListener('keydown', (e) => {
            gameState.keys[e.key] = true;
            if (e.key === 'z' || e.key === 'Z') {
                e.preventDefault();
                fireBullet();
            }
            if (e.key === 'r' || e.key === 'R') {
                resetGame();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            gameState.keys[e.key] = false;
        });
        
        function drawSprite(x, y, color, type, animFrame, direction) {
            ctx.save();
            animFrame = animFrame || 0;
            direction = direction || 'down';
            
            if (type === 'player') {
                // Animated player sprite with running animation
                const legOffset = animFrame % 2 === 0 ? 2 : -2;
                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 0.5;
                
                // Head
                ctx.beginPath();
                ctx.arc(x, y - 5, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Body
                ctx.fillRect(x - 1, y - 2, 2, 7);
                
                // Arms (animated)
                ctx.fillRect(x - 4, y + (animFrame % 2), 3, 2);
                ctx.fillRect(x + 1, y + ((animFrame + 1) % 2), 3, 2);
                
                // Legs (animated running)
                ctx.fillRect(x - 2, y + 5, 2, 4 - legOffset);
                ctx.fillRect(x + 1, y + 5, 2, 4 + legOffset);
                
                // Gun
                ctx.fillStyle = '#888';
                if (direction === 'right') ctx.fillRect(x + 2, y, 3, 2);
                else if (direction === 'left') ctx.fillRect(x - 5, y, 3, 2);
                else ctx.fillRect(x - 1, y + 3, 2, 3);
                
            } else if (type === 'spider') {
                // Pink/magenta spider with legs
                ctx.fillStyle = color;
                // Body
                ctx.fillRect(x - 3, y - 3, 6, 6);
                // Legs (4 pairs)
                for (let i = -1; i <= 1; i++) {
                    ctx.fillRect(x - 6, y + i * 2, 3, 1);
                    ctx.fillRect(x + 3, y + i * 2, 3, 1);
                }
                // Eyes
                ctx.fillStyle = '#fff';
                ctx.fillRect(x - 2, y - 2, 1, 1);
                ctx.fillRect(x + 1, y - 2, 1, 1);
                
            } else if (type === 'scorpion') {
                // Blue scorpion with tail
                ctx.fillStyle = color;
                // Body
                ctx.fillRect(x - 4, y - 2, 8, 4);
                // Claws
                ctx.fillRect(x - 6, y - 3, 2, 2);
                ctx.fillRect(x + 4, y - 3, 2, 2);
                // Tail segments (curved)
                ctx.fillRect(x + 3, y - 4, 2, 2);
                ctx.fillRect(x + 4, y - 6, 2, 2);
                // Stinger
                ctx.fillStyle = '#ff0';
                ctx.fillRect(x + 5, y - 7, 1, 1);
                
            } else if (type === 'snake') {
                // Red snake (S-shaped)
                ctx.fillStyle = color;
                const sway = Math.sin(animFrame * 0.2) * 2;
                // Head
                ctx.fillRect(x - 2, y - 4 + sway, 4, 3);
                // Body segments
                ctx.fillRect(x - 1 + sway, y - 1, 3, 2);
                ctx.fillRect(x - sway, y + 1, 3, 2);
                ctx.fillRect(x + sway, y + 3, 3, 2);
                // Tongue
                ctx.fillStyle = '#f00';
                ctx.fillRect(x - 3, y - 4 + sway, 1, 1);
                
            } else if (type === 'bat') {
                // Brown bat with wing flap animation
                ctx.fillStyle = color;
                const wingFlap = animFrame % 4 < 2 ? 0 : 2;
                // Body
                ctx.fillRect(x - 2, y - 2, 4, 4);
                // Head
                ctx.fillRect(x - 1, y - 4, 2, 2);
                // Wings
                ctx.fillRect(x - 6 - wingFlap, y - 1, 4, 2);
                ctx.fillRect(x + 2 + wingFlap, y - 1, 4, 2);
                // Ears
                ctx.fillRect(x - 2, y - 5, 1, 1);
                ctx.fillRect(x + 1, y - 5, 1, 1);
                
            } else if (type === 'dragon') {
                // Pink dragon
                ctx.fillStyle = color;
                // Head
                ctx.fillRect(x - 3, y - 4, 6, 5);
                // Horns
                ctx.fillRect(x - 4, y - 6, 2, 2);
                ctx.fillRect(x + 2, y - 6, 2, 2);
                // Body
                ctx.fillRect(x - 2, y + 1, 4, 4);
                // Tail
                ctx.fillRect(x + 2, y + 3, 3, 2);
                // Eyes
                ctx.fillStyle = '#f00';
                ctx.fillRect(x - 2, y - 3, 1, 1);
                ctx.fillRect(x + 1, y - 3, 1, 1);
            } else if (type === 'robot') {
                // Gray robot
                ctx.fillStyle = color;
                // Body
                ctx.fillRect(x - 4, y - 5, 8, 10);
                // Head
                ctx.fillRect(x - 3, y - 7, 6, 3);
                // Arms
                ctx.fillRect(x - 6, y - 2, 2, 4);
                ctx.fillRect(x + 4, y - 2, 2, 4);
                // Legs
                ctx.fillRect(x - 3, y + 5, 2, 3);
                ctx.fillRect(x + 1, y + 5, 2, 3);
                // Eyes (red)
                ctx.fillStyle = '#f00';
                ctx.fillRect(x - 2, y - 6, 1, 1);
                ctx.fillRect(x + 1, y - 6, 1, 1);
                // Antenna
                ctx.fillStyle = color;
                ctx.fillRect(x - 1, y - 9, 2, 2);
            }
            
            ctx.restore();
        }
        
        function drawBullet(bullet) {
            if (bullet.isWeb) {
                // Spider web projectile (grey/white)
                ctx.save();
                
                // Web strands
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 8;
                ctx.shadowColor = '#ccc';
                
                ctx.beginPath();
                ctx.moveTo(bullet.x - 3, bullet.y - 3);
                ctx.lineTo(bullet.x + 3, bullet.y + 3);
                ctx.moveTo(bullet.x + 3, bullet.y - 3);
                ctx.lineTo(bullet.x - 3, bullet.y + 3);
                ctx.stroke();
                
                // Center dot
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.restore();
            } else if (bullet.isRobotBullet) {
                // Red robot disc (slower and more threatening)
                ctx.save();
                
                // Outer glow
                ctx.shadowBlur = 12;
                ctx.shadowColor = '#f00';
                
                // Disc outer ring
                ctx.fillStyle = '#f00';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner darker center
                ctx.fillStyle = '#800';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Bright center dot
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 1, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.restore();
            } else {
                // Yellow Tron disc with glow (player bullets)
                ctx.save();
                
                // Outer glow
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ff0';
                
                // Disc outer ring
                ctx.fillStyle = '#ff0';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner darker center
                ctx.fillStyle = '#cc0';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Bright center dot
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 1, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }
        
        function drawBumpyWall(x, y, width, height) {
            // Base wall color (black)
            ctx.fillStyle = '#000';
            ctx.fillRect(x, y, width, height);
            
            // Add bumpy texture (dark grey)
            ctx.fillStyle = '#111';
            const bumpSize = 3;
            
            // Bumps on edges
            if (width > height) {
                // Horizontal wall - bumps on top and bottom
                for (let i = 0; i < width; i += bumpSize * 2) {
                    if (Math.random() > 0.5) {
                        ctx.fillRect(x + i, y - 1, bumpSize, 2);
                        ctx.fillRect(x + i, y + height - 1, bumpSize, 2);
                    }
                }
            } else {
                // Vertical wall - bumps on sides
                for (let i = 0; i < height; i += bumpSize * 2) {
                    if (Math.random() > 0.5) {
                        ctx.fillRect(x - 1, y + i, 2, bumpSize);
                        ctx.fillRect(x + width - 1, y + i, 2, bumpSize);
                    }
                }
            }
            
            // Highlight edge (very dark grey)
            ctx.fillStyle = '#222';
            ctx.fillRect(x, y, 1, height);
            ctx.fillRect(x, y, width, 1);
        }
        
        function drawSpiderWeb(cx, cy, size) {
            ctx.strokeStyle = 'rgba(200, 200, 200, 0.6)';
            ctx.lineWidth = 1;
            
            // Radial lines
            const spokes = 8;
            for (let i = 0; i < spokes; i++) {
                const angle = (Math.PI * 2 / spokes) * i;
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(cx + Math.cos(angle) * size, cy + Math.sin(angle) * size);
                ctx.stroke();
            }
            
            // Concentric circles
            const circles = 4;
            for (let i = 1; i <= circles; i++) {
                ctx.beginPath();
                ctx.arc(cx, cy, (size / circles) * i, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        function drawMaze() {
            // Background (blue paths)
            ctx.fillStyle = '#0066cc';
            ctx.fillRect(0, 0, 320, 240);
            
            // Draw walls with bumpy texture
            walls.forEach(wall => {
                drawBumpyWall(wall.x, wall.y, wall.width, wall.height);
            });
            
            // Draw door gaps in corner boxes
            ctx.fillStyle = '#0066cc';
            // Top-left box door (bottom)
            ctx.fillRect(55, 70, 15, 8);
            // Top-right box door (bottom) 
            ctx.fillRect(245, 85, 15, 8);
            // Bottom-left box door (top)
            ctx.fillRect(50, 165, 15, 8);
            // Bottom-right box door (top)
            ctx.fillRect(260, 160, 15, 8);
            
            // Draw spider web in top-left corner
            drawSpiderWeb(50, 50, 40);
            
            // Bunker (grey cell with vertical bars)
            ctx.fillStyle = '#666';
            ctx.fillRect(gameState.bunker.x, gameState.bunker.y, 
                        gameState.bunker.width, gameState.bunker.height);
            
            // Bunker bars (vertical - darker grey)
            ctx.fillStyle = '#333';
            const barCount = 5;
            const barSpacing = gameState.bunker.width / (barCount + 1);
            for (let i = 1; i <= barCount; i++) {
                const barX = gameState.bunker.x + i * barSpacing;
                ctx.fillRect(barX - 1, gameState.bunker.y + 5, 2, gameState.bunker.height - 10);
            }
            
            // Bunker entrance (bottom opening - blue)
            ctx.fillStyle = '#0066cc';
            ctx.fillRect(gameState.bunker.x + 10, 
                        gameState.bunker.y + gameState.bunker.height - 3, 
                        gameState.bunker.width - 20, 3);
        }
        
        function drawLeftDoor() {
            const door = gameState.leftDoor;
            
            if (door.open) {
                // Open door - blue opening (path visible)
                ctx.fillStyle = '#0066cc';
                ctx.fillRect(door.x, door.y, door.width, door.height);
                
                // Door edges (dark)
                ctx.fillStyle = '#333';
                ctx.fillRect(door.x, door.y - 2, door.width, 2);
                ctx.fillRect(door.x, door.y + door.height, door.width, 2);
            } else {
                // Closed door - matches wall (black)
                ctx.fillStyle = '#000';
                ctx.fillRect(door.x, door.y, door.width, door.height);
                
                // Door outline
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;
                ctx.strokeRect(door.x, door.y, door.width, door.height);
            }
        }
        
        function drawHUD() {
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px "Courier New"';
            ctx.fillText(`${gameState.score}`, 135, 18);
            
            ctx.font = '12px "Courier New"';
            ctx.fillText(`LIVES: ${gameState.lives}`, 240, 18);
            ctx.fillText(`‚àû AMMO`, 10, 18);
        }
        
        function updatePlayer() {
            const speed = 2;
            let newX = gameState.player.x;
            let newY = gameState.player.y;
            let moving = false;
            
            if (gameState.keys['ArrowUp']) {
                newY -= speed;
                gameState.player.direction = 'up';
                moving = true;
            }
            if (gameState.keys['ArrowDown']) {
                newY += speed;
                gameState.player.direction = 'down';
                moving = true;
            }
            if (gameState.keys['ArrowLeft']) {
                newX -= speed;
                gameState.player.direction = 'left';
                moving = true;
            }
            if (gameState.keys['ArrowRight']) {
                newX += speed;
                gameState.player.direction = 'right';
                moving = true;
            }
            
            gameState.player.moving = moving;
            
            // Animate player when moving
            if (moving) {
                gameState.player.animFrame++;
            }
            
            // Check wall collisions
            if (!checkWallCollision(newX, newY, gameState.player.size)) {
                gameState.player.x = newX;
                gameState.player.y = newY;
            }
            
            // Keep in bounds
            gameState.player.x = Math.max(16, Math.min(304, gameState.player.x));
            gameState.player.y = Math.max(16, Math.min(224, gameState.player.y));
        }
        
        function checkWallCollision(x, y, size) {
            for (let wall of walls) {
                if (x - size < wall.x + wall.width &&
                    x + size > wall.x &&
                    y - size < wall.y + wall.height &&
                    y + size > wall.y) {
                    return true;
                }
            }
            return false;
        }
        
        function isInBunker(entity) {
            return entity.x > gameState.bunker.x &&
                   entity.x < gameState.bunker.x + gameState.bunker.width &&
                   entity.y > gameState.bunker.y &&
                   entity.y < gameState.bunker.y + gameState.bunker.height;
        }
        
        function updateRobot() {
            const robot = gameState.robot;
            
            // Don't spawn robot during start delay
            if (gameState.startDelay > 0) return;
            
            // Random chance to spawn robot
            if (!robot.alive && Math.random() > 0.995) {
                robot.alive = true;
                robot.x = 160;
                robot.y = 120;
                robot.wanderTarget = null;
                robot.lastShot = 0;
            }
            
            // Robot AI - patrol and hunt player
            if (robot.alive) {
                robot.animFrame++;
                const speed = 1.2;
                
                // Robot shooting (every 90 frames = ~1.5 seconds)
                if (frameCount - robot.lastShot > 90) {
                    const dx = gameState.player.x - robot.x;
                    const dy = gameState.player.y - robot.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 150) { // Shoot if player is close enough
                        const speed = 2; // Slower than player discs
                        const vx = (dx / dist) * speed;
                        const vy = (dy / dist) * speed;
                        
                        gameState.activeBullets.push({
                            x: robot.x,
                            y: robot.y,
                            vx: vx,
                            vy: vy,
                            life: 120,
                            isRobotBullet: true
                        });
                        
                        playRobotShootSound();
                        robot.lastShot = frameCount;
                    }
                }
                
                // Decide between hunting player and wandering
                const dx = gameState.player.x - robot.x;
                const dy = gameState.player.y - robot.y;
                const distToPlayer = Math.sqrt(dx * dx + dy * dy);
                
                let targetX, targetY;
                
                // If player is close, hunt them
                if (distToPlayer < 100) {
                    targetX = gameState.player.x;
                    targetY = gameState.player.y;
                    robot.wanderTarget = null;
                } else {
                    // Wander through maze - pick random targets
                    if (!robot.wanderTarget || Math.random() > 0.98) {
                        robot.wanderTarget = {
                            x: 50 + Math.random() * 220,
                            y: 50 + Math.random() * 140
                        };
                    }
                    targetX = robot.wanderTarget.x;
                    targetY = robot.wanderTarget.y;
                }
                
                const dx2 = targetX - robot.x;
                const dy2 = targetY - robot.y;
                const dist = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                
                if (dist > 5) {
                    let newX = robot.x + (dx2 / dist) * speed;
                    let newY = robot.y + (dy2 / dist) * speed;
                    
                    // Try moving in both X and Y
                    if (!checkWallCollision(newX, newY, robot.size)) {
                        robot.x = newX;
                        robot.y = newY;
                    } else {
                        // Try just X
                        if (!checkWallCollision(newX, robot.y, robot.size)) {
                            robot.x = newX;
                        } 
                        // Try just Y
                        else if (!checkWallCollision(robot.x, newY, robot.size)) {
                            robot.y = newY;
                        }
                        // Stuck - pick new wander target
                        else {
                            robot.wanderTarget = null;
                        }
                    }
                }
                
                // Check collision with player
                if (distToPlayer < 12 && !isInBunker(gameState.player)) {
                    playerHit();
                }
            }
        }
        
        function updateBullets() {
            // Update active bullets
            gameState.activeBullets = gameState.activeBullets.filter(bullet => {
                // Move bullet
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                bullet.life--;
                
                // Remove if off screen or expired
                if (bullet.x < 0 || bullet.x > 320 || bullet.y < 0 || bullet.y > 240 || bullet.life <= 0) {
                    return false;
                }
                
                // Check wall collision
                if (checkWallCollision(bullet.x, bullet.y, 2)) {
                    return false;
                }
                
                // Robot bullets can hit player
                if (bullet.isRobotBullet) {
                    const dist = Math.sqrt(
                        Math.pow(bullet.x - gameState.player.x, 2) + 
                        Math.pow(bullet.y - gameState.player.y, 2)
                    );
                    if (dist < 8 && !isInBunker(gameState.player)) {
                        playerHit();
                        return false;
                    }
                    return true;
                }
                
                // Web bullets can hit player
                if (bullet.isWeb) {
                    const dist = Math.sqrt(
                        Math.pow(bullet.x - gameState.player.x, 2) + 
                        Math.pow(bullet.y - gameState.player.y, 2)
                    );
                    if (dist < 8 && !isInBunker(gameState.player)) {
                        playerHit();
                        return false;
                    }
                    return true;
                }
                
                // Player bullets can hit enemies
                for (let enemy of gameState.enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt(
                        Math.pow(bullet.x - enemy.x, 2) + 
                        Math.pow(bullet.y - enemy.y, 2)
                    );
                    if (dist < 8) {
                        enemy.alive = false;
                        const points = {
                            'spider': 100, 'scorpion': 150, 'snake': 175,
                            'bat': 200, 'dragon': 250
                        };
                        gameState.score += points[enemy.type] || 100;
                        playKillSound();
                        return false;
                    }
                }
                
                // Player bullets can hit robot
                if (gameState.robot.alive) {
                    const dist = Math.sqrt(
                        Math.pow(bullet.x - gameState.robot.x, 2) + 
                        Math.pow(bullet.y - gameState.robot.y, 2)
                    );
                    if (dist < 10) {
                        gameState.robot.alive = false;
                        gameState.score += 300;
                        playKillSound();
                        return false;
                    }
                }
                
                return true;
            });
        }
        
        function updateEnemies() {
            // Don't move enemies during start delay
            if (gameState.startDelay > 0) {
                gameState.startDelay--;
                return;
            }
            
            gameState.enemies.forEach(enemy => {
                if (!enemy.alive) return;
                
                // Animate enemies
                enemy.animFrame++;
                
                // Spider shooting webs
                if (enemy.type === 'spider' && frameCount - enemy.lastShot > 120) {
                    const dx = gameState.player.x - enemy.x;
                    const dy = gameState.player.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 120) { // Shoot if player is close
                        const speed = 1.5; // Slow web
                        const vx = (dx / dist) * speed;
                        const vy = (dy / dist) * speed;
                        
                        gameState.activeBullets.push({
                            x: enemy.x,
                            y: enemy.y,
                            vx: vx,
                            vy: vy,
                            life: 150,
                            isWeb: true
                        });
                        
                        enemy.lastShot = frameCount;
                    }
                }
                
                // Different movement patterns per enemy type
                if (enemy.type === 'bat') {
                    // Bat moves up and down
                    const speed = 1;
                    enemy.y += speed * enemy.direction;
                    
                    // Bounce off walls or change direction
                    if (enemy.y < 30 || enemy.y > 210 || checkWallCollision(enemy.x, enemy.y + speed * enemy.direction, enemy.size)) {
                        enemy.direction *= -1;
                    }
                } else {
                    // Other enemies patrol slowly through maze
                    const speed = 0.5; // Slow patrol speed
                    
                    // Wander through maze - pick random targets
                    if (!enemy.wanderTarget || Math.random() > 0.995) {
                        enemy.wanderTarget = {
                            x: 50 + Math.random() * 220,
                            y: 50 + Math.random() * 140
                        };
                    }
                    
                    if (enemy.wanderTarget) {
                        const dx = enemy.wanderTarget.x - enemy.x;
                        const dy = enemy.wanderTarget.y - enemy.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist > 5) {
                            let newX = enemy.x + (dx / dist) * speed;
                            let newY = enemy.y + (dy / dist) * speed;
                            
                            // Try moving in both X and Y
                            if (!checkWallCollision(newX, newY, enemy.size)) {
                                enemy.x = newX;
                                enemy.y = newY;
                            } else {
                                // Try just X
                                if (!checkWallCollision(newX, enemy.y, enemy.size)) {
                                    enemy.x = newX;
                                } 
                                // Try just Y
                                else if (!checkWallCollision(enemy.x, newY, enemy.size)) {
                                    enemy.y = newY;
                                }
                                // Stuck - pick new wander target
                                else {
                                    enemy.wanderTarget = null;
                                }
                            }
                        }
                    }
                    
                    // Snake S-pattern overlay
                    if (enemy.type === 'snake') {
                        enemy.x += Math.sin(enemy.animFrame * 0.1) * 0.5;
                    }
                }
                
                // Check collision with player
                const dist = Math.sqrt(
                    Math.pow(enemy.x - gameState.player.x, 2) +
                    Math.pow(enemy.y - gameState.player.y, 2)
                );
                
                if (dist < 12 && !isInBunker(gameState.player)) {
                    playerHit();
                }
            });
        }
        
        function fireBullet() {
            // Unlimited ammo - no check needed
            
            // Create bullet projectile
            const speed = 6;
            let vx = 0, vy = 0;
            
            // Direction based on player direction
            if (gameState.player.direction === 'up') vy = -speed;
            else if (gameState.player.direction === 'down') vy = speed;
            else if (gameState.player.direction === 'left') vx = -speed;
            else if (gameState.player.direction === 'right') vx = speed;
            else vy = -speed; // default up
            
            gameState.activeBullets.push({
                x: gameState.player.x,
                y: gameState.player.y,
                vx: vx,
                vy: vy,
                life: 100
            });
            
            playShootSound();
            
            // Check if all enemies defeated
            if (gameState.enemies.every(e => !e.alive)) {
                nextLevel();
            }
        }
        
        function playerHit() {
            gameState.lives -= 1;
            playHitSound();
            
            if (gameState.lives <= 0) {
                gameState.gameOver = true;
                playGameOverSound();
                statusDiv.textContent = `GAME OVER! Final Score: ${gameState.score}`;
            } else {
                // Return player to center cell (bunker)
                gameState.player.x = gameState.bunker.x + gameState.bunker.width / 2;
                gameState.player.y = gameState.bunker.y + gameState.bunker.height / 2;
                gameState.player.direction = 'down';
                
                // Brief pause before enemies resume
                gameState.startDelay = 60;
            }
        }
        
        function nextLevel() {
            gameState.level += 1;
            gameState.score += 500;
            gameState.startDelay = 120;
            playLevelUpSound();
            
            // Respawn enemies with increased difficulty
            gameState.enemies = [
                { x: 70, y: 60, size: 8, color: '#f0f', type: 'spider', alive: true, animFrame: 0, wanderTarget: null, lastShot: 0 },
                { x: 280, y: 100, size: 8, color: '#00f', type: 'scorpion', alive: true, animFrame: 0, wanderTarget: null },
                { x: 280, y: 200, size: 8, color: '#f00', type: 'snake', alive: true, animFrame: 0, wanderTarget: null },
                { x: 70, y: 200, size: 8, color: '#8b4513', type: 'bat', alive: true, animFrame: 0, direction: 1 },
                { x: 280, y: 60, size: 8, color: '#ff1493', type: 'dragon', alive: true, animFrame: 0, wanderTarget: null }
            ];
            
            gameState.robot.alive = false;
            gameState.robot.wanderTarget = null;
            gameState.robot.lastShot = 0;
            gameState.robot.lastShot = 0;
            
            statusDiv.textContent = `Level ${gameState.level}!`;
        }
        
        function gameLoop() {
            if (!gameState.running || gameState.gameOver) return;
            
            // Clear canvas
            ctx.clearRect(0, 0, 320, 240);
            
            // Draw everything
            drawMaze();
            
            // Update game state
            updatePlayer();
            updateEnemies();
            updateRobot();
            updateBullets();
            
            // Draw bullets
            gameState.activeBullets.forEach(bullet => {
                drawBullet(bullet);
            });
            
            // Draw entities
            drawSprite(gameState.player.x, gameState.player.y, 
                      gameState.player.color, 'player', 
                      gameState.player.animFrame, gameState.player.direction);
            
            gameState.enemies.forEach(enemy => {
                if (enemy.alive) {
                    drawSprite(enemy.x, enemy.y, enemy.color, enemy.type, enemy.animFrame);
                }
            });
            
            // Draw robot
            if (gameState.robot.alive) {
                drawSprite(gameState.robot.x, gameState.robot.y, 
                          gameState.robot.color, 'robot', gameState.robot.animFrame);
            }
            
            drawHUD();
            
            // Increment global frame counter
            frameCount++;
            
            requestAnimationFrame(gameLoop);
        }
        
        function startGame() {
            if (!gameState.running) {
                initAudio();
                gameState.running = true;
                gameState.gameOver = false;
                statusDiv.textContent = 'Game Running - Good Luck!';
                gameLoop();
            }
        }
        
        function resetGame() {
            gameState = {
                score: 1000,
                lives: 5,
                bullets: 999,
                level: 1,
                startDelay: 120,
                player: { 
                    x: 160, y: 120, size: 8, color: '#fff', 
                    direction: 'down', animFrame: 0, moving: false 
                },
                enemies: [
                    { x: 70, y: 60, size: 8, color: '#f0f', type: 'spider', alive: true, animFrame: 0, wanderTarget: null, lastShot: 0 },
                    { x: 280, y: 100, size: 8, color: '#00f', type: 'scorpion', alive: true, animFrame: 0, wanderTarget: null },
                    { x: 280, y: 200, size: 8, color: '#f00', type: 'snake', alive: true, animFrame: 0, wanderTarget: null },
                    { x: 70, y: 200, size: 8, color: '#8b4513', type: 'bat', alive: true, animFrame: 0, direction: 1 },
                    { x: 280, y: 60, size: 8, color: '#ff1493', type: 'dragon', alive: true, animFrame: 0, wanderTarget: null }
                ],
                robot: { x: 160, y: 120, size: 10, color: '#888', type: 'robot', alive: false, animFrame: 0, wanderTarget: null, lastShot: 0 },
                activeBullets: [],
                bunker: { x: 140, y: 100, width: 40, height: 40 },
                keys: {},
                gameOver: false,
                running: false
            };
            frameCount = 0;
            statusDiv.textContent = 'Game Reset - Press START to play';
        }
        
        // Initialize
        statusDiv.textContent = 'Ready to play! Press START GAME';
        drawMaze();
    </script>
</body>
</html>
